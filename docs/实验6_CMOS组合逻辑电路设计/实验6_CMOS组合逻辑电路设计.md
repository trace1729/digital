# 实验6 CMOS组合逻辑门的设计
“The complexity for minimum component costs has increased at a rate of roughly a factor of two per year. Certainly over the short term this rate can be expected to continue, if not to increase. Over the longer term, the rate of increase is a bit more uncertain, although there is no reason to believe it will not remain nearly constant for at least 10 years. That means by 1975, the number of components per integrated circuit for minimum cost will be 65,000.”
（“最低成本的元器件的复杂度大概每年翻一番。可以预见在短期内这个速率将继续下去，甚至还会增加。虽然从长远来看这个速率的增速还不能确定，但我们相信至少在10年内它将会保持。这意味着到1975年，最低成本的每个集成电路中的元器件数目将会达到65 000个。”）

——《Cramming more components onto integrated circuits》（《在集成电路上“塞进”更多的元器件》），Gordon E. Moore

在学习了最简单的门——非门（反相器），以及一些数字集成电路常用的分析手段后，我们便可以把我们的胃口放的更大一些。我们将依次实现与非门、或非门、与门、非门、异或门以及同或门等数字电路中最常见的基本组合逻辑门，并且还将介绍任意组合逻辑门的构建方法，我们还将介绍动态逻辑并且将传输门逻辑和多米诺逻辑等作为选学内容，以飨读者。
## 6.1.上拉网络（PUN）和下拉网络（PDN）
与反相器一样，我们构建其他的门的方法，也是利用CMOS电路互补的特点。一个通用的N个输入的逻辑门由上拉网络（PUN）和下拉网络（PDN）构成。其工作原理是，输出信号F总会通过PUN连接到VDD（输出数字逻辑“1”）或者通过PDN连接到GND（输出数字逻辑“0”）。

![](./图片/图片%201.png)

## 6.2.与非门（NAND）、或非门（NOR）
我们首先给出与与非门（NAND）以及或非门（NOR）的CMOS电路图：

![](./图片/图片%203.png)

图 1 与非门CMOS电路图	

![](./图片/图片%202.png)

图 2 或非门CMOS电路图

我们来分析一下它们的工作原理：
对于与非门，当输入信号a，b均为0时，下拉网络（PDN）中的两个NMOS均关断，上拉网络（PUN）中的两个PMOS均导通，因此，输出y通过PMOS连接到VDD。只要输入信号a，b中的任意一个为0，PUN中总会有1个PMOS导通，进而使得输出为VDD。只有当输入信号a，b均为VDD（数字逻辑“1”）时，PDN的2个NMOS才都导通，PUN的2个PMOS才都关断，输入才被连接到GND（数字逻辑“0”）。或非门的情况请读者自行分析。
## 6.3.与门（AND）、或门（OR）
我们有了与非门，或非门，那么我们怎么才能得到与门和或门呢？聪明的你，一定已经想到了，就是增加一个非门（反相器）。
![](./图片/图片%204.png)

![](./图片/图片%205.png)

我们不妨来总结一下CMOS组合逻辑门的特点：
1. CMOS电路“天生”适合产生反逻辑电路，如果希望产生正逻辑，则需要增加一个反相器。
2. CMOS组合逻辑门的PDN使用NMOS，PUN使用PMOS。PDN和PUN的拓扑结构完全相反（例如PDN中的NMOS串联，则PUN中的PMOS并联）。
3. PDN中NMOS串联表示逻辑“与”，NMOS并联表示逻辑“或”。PUN中PMOS的情况完全相反。
最终四个门的输出结果如下：
![](./图片/图片%206.png)

你可以分析一下这些输出的毛刺为什么出现吗？以及避免毛刺的方法。
## 6.4.异或门（XOR）
理论上来说，有了与，或，非三种逻辑门，我们就可以实现任意逻辑门，比如异或门和同或门其实就可以通过与门、或门和非门来实现。大家可以算一下，如果我们只是用与门、或门和非门实现异或门，异或的逻辑表达式为：，一共需要2个与门、1个或门、2个非门，一共22个晶体管。而异或门又是我们处理器芯片经常用到的门电路，所以我们不妨思考一下，可不可以直接通过晶体管电路来搭建呢？
我们不妨将异或的逻辑表达式改变一下，还记得我们说CMOS电路天生适合产生反逻辑吗？我们将异或表达式从正逻辑改为反逻辑：，然后使用NMOS搭建PDN，并在实现对应的PUN。该电路中只使用了12个晶体管（包括产生a_bar和b_bar的反相器），最终电路图如下：
![](./图片/图片%207.png)

![](./图片/图片%208.png)

可以看到，在PDN中，输入信号为a，b的2个晶体管串联，并且与输入信号为a_bar和b_bar的2个串联的晶体管并联。在PUN中正好完全相反。
## 6.5.构建CMOS复合门的流程
从刚刚构建异或门的过程中，我们其实已经了解了如何构建一个复合门，下面我们总结一下这个流程：
1. 写出逻辑表达式，并把输出变为反逻辑形式。
2. 先使用NMOS构建出PDN，NMOS串联表示逻辑“与”，NMOS并联表示逻辑“或”。
3. 最后使用PMOS按照“相反对称”的方式构建出PUN。
## 6.6.传输门
在数字集成电路中，当我们希望使用一个“门控开关”时，我们就会使用传输门。
传输门巧妙的利用了NMOS和PMOS互补的特性：NMOS擅长传递逻辑0，不擅长传递逻辑1（阈值损失，只能充电到VDD-VTH）；而PMOS擅长传递逻辑1，不擅长传递逻辑0（阈值损失，请读者STFW）。传输门将二者并联，由控制信号C和C’控制导通和关断。
![](./图片/图片%209.png)

![](./图片/图片%2010.png)

我们来分析一下电路的工作原理：当C=VDD，C_bar=0时，NMOS和PMOS均导通，PMOS传输高电平NMOS传输低电平；当C=0，C_bar=VDD时，NMOS和PMOS均关断，传输门关断，输出为高阻态（随机值）。
这里请大家思考几个问题：
Q1：为什么需要NMOS和PMOS，能否只是用一种类型的晶体管？
Q2：为什么NMOS的B极需要接GND，PMOS的B极需要接VDD
Q3：何为高阻态？为什么传输门关断时输出为随机电压值？
## 6.7.*（选学）到此为止了吗？
我们总是希望可以使用更少的晶体管实现同样的功能，那么我们是否可以用更少的晶体管实现与，或，非等逻辑呢？
传输管逻辑和传输门逻辑为我们指明了新的道路。这里只给出通过传输门构建双路复选器MUX的例子，其他例子请读者自行STWF。
![](./图片/图片%2012.png)

![](./图片/图片%2011.png)

## 6.8.动态CMOS组合逻辑
在使用静态CMOS逻辑时，有N个输入信号最少需要有2N个晶体管实现完整的互补逻辑（例如一个2输入与非门就需要2个NMOS和2个PMOS实现）。而如果我们通过引入一个时钟CLK信号，就可以只使用N+2个晶体管实现完整的逻辑，这在输入信号较大时很有吸引力。而且动态逻辑在速度和功耗方面都有着不错的表现。当然，天下没有免费的午餐，动态逻辑的本质是利用了电容存储电荷，而这些宝贵的电荷，就像一个杯子中的水一样，一点风吹草动就会使得这些水洒在地上（电荷流失），而我们却没有任何办法弥补这些丢失的电荷。因此在使用动态逻辑之前，请仔细的检查电路节点。
动态逻辑的设计也启发我们：一方面寄生电容会导致电路速度降低，限制了芯片的性能，另一方面，我们也可以利用寄生电容来实现动态逻辑的功能，正所谓“化腐朽为神奇”。
一个4输入动态CMOS与非门的电路原理图如下：

![](./图片/图片%2013.png)

![](./图片/图片%2014.png)

对于动态CMOS来说，一个完整的求值过程分为两部分，预充电阶段和求值阶段。
预充电阶段：此时，CLK=0，PMOS导通，NMOS截止。因此，输出F节点被充电到VDD，并且由晶体管的电容保持在VDD。
求值阶段：此时，CLK=VDD，PMOS关断，NMOS导通。如果此时PDN满足某一条件，其中的NMOS均导通（例如与非门的输入信号均为1），那么PDN形成通路，并且下方的NMOS也导通，输出F节点的电压就被放电到0（本质是输出节点上寄生电容的电荷流走了）。如果不满足逻辑条件（例如与非门的输入信号有1个为0），那么PDN不形成通路，输出节点F仍然保持高电平。
可惜，直接串联动态门形成多级逻辑结构的方法并不可行，具体原因以及解决方法请大家自行STFW，大家可以搜索电荷泄漏和电荷分享来了解为什么不可以直接串联动态门，搜索多米诺逻辑和np-CMOS来了解解决动态门串联的方法。
当前数字集成电路设计的趋势时互补静态CMOS的运用增多。有两方面的原因：1）逻辑设计层次上越来越多的使用EDA工具，这些工具的重点放在逻辑层次而不是电路层次的优化，并且非常重视提高稳定性。2）静态CMOS更适合与降低电压，而电压与功耗直接相关，因此静态CMOS设计尤其适合低功耗芯片的设计。
## 6.9.动手实验内容
1. 设计4输入与门。
2. 实现一个4输入的CMOS复合门。（例如F = (ABCD)’ + (AB)’ + C + D）
3. 通过传输门实现传输门异或门
4. 把动态CMOS逻辑中的CLK的时钟延迟取消，看结果，并思考为什么结果错误
5. 把动态CMOS逻辑中的所有的MOSFET换成标准模型（NMOS PMOS），观察输出结果，并想一下为什么结果不正确